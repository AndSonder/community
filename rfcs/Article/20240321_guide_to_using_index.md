# Tensor 索引的使用指南&学习心得

## 1. 引言

在深度学习的世界中，数据是一切算法和模型的基础。有效、高效地处理数据，特别是在处理高维数组或张量（Tensor）时，成为了构建模型、处理数据等任务的重要部分。PaddlePaddle，作为一个前沿的深度学习框架，提供了丰富的Tensor索引操作，极大地简化了Tensor的操作和处理。本文基于Paddle框架，详细介绍Tensor索引的概念、功能、使用场景，并结合具体的代码示例，展示了在不同领域模型中索引的实际应用，以及个人的学习心得。

## 2. Tensor索引的基本概念

索引操作是深度学习中数据处理的基础。想象一下，当我们面对一个多维度、庞大复杂的数据集时，如何快速准确地访问到我们需要的数据片段？答案就在于Tensor索引。Tensor索引，简而言之，就是指在多维数组中访问其子集的过程。它可以是一个元素、一行、一列、一个面或者是任何跨越多个维度的复杂形状。

PaddlePaddle在这方面提供了极其丰富的操作，从基础的切片和挑选，到复杂的条件筛选和维度变换，都可以通过简洁直观的索引完成。更重要的是，PaddlePaddle中的索引操作不仅仅是数据访问那么简单，它还直接关系到框架的自动微分机制和梯度传播，这对于构建复杂的神经网络模型至关重要。

## 3. 基础索引

### 3.1 单个整形或整形的 0-D Tensor/Ndarray

在PaddlePaddle中，我们可以通过整形或整形的 0-D Tensor/Ndarray 来访问 Tensor 中的单个元素。这与 Python 原生类型的索引规则类似, 表示选择对应轴上的具体位置的元素, 从 0 开始计数, 也可以接收负数作为输入, 表示从对应轴的最后开始计数。

```python
import paddle

# 使用单个整数索引
a = paddle.arange(6).reshape((2,3))
print(a)
# Tensor Output:
# [[0, 1, 2], 
#  [3, 4, 5]]

b = a[1]  # 选取第二行
print(b)
# Tensor Output: [3, 4, 5]

c = a[-1] # 选取最后一行 
print(c)
# Tensor Output: [3, 4, 5]
```

可以看到,b 和 c 分别选取了第二行和最后一行,它们的形状从原来的 (2,3) 降为 (3,)。

从Paddle 2.5开始,使用0-D Tensor而非1-D Tensor表示Scalar语义。因此0-D Tensor可以直接用于索引:

```python
index = paddle.to_tensor(1, dtype='int32') 
print(a[index])
# Tensor Output: [3, 4, 5]
```

这里 index 是一个 0-D Tensor,等价于 Python 整数 1,用于选取第二行。

总之,使用单个整数或0-D 整数 Tensor 索引,可以精确选取指定轴上的单个元素。对于多维数据,可以在不同轴上同时指定索引,最终返回一个降低维度后的 Tensor 或 0-D Tensor。

### 3.2 使用 Python slice 对象作为索引

slice 对象由 start/end/step 三个参数定义,用于指定在某个轴上选取的元素范围和步长。它的语义与 Python 内置的序列切片操作相同。对于 start/end/step 同样可以是整数,也可以是对应的 0-D Tensor/Ndarray,还可以是负数。当为负数时,start/end 表示从对应轴的最后开始计数,step 为负数时,表示逆序选取。在取值场景中,该轴对应的维度将被保留,大小为选取到的元素数量。

```python
import paddle

a = paddle.arange(10).reshape((2,5))
print(a)
# Tensor Output: 
# [[0, 1, 2, 3, 4],
#  [5, 6, 7, 8, 9]]

# 基本切片
b = a[0, 1:4]  # 选取第一行,第二个到第四个元素(不包括第四个)
print(b)
# Tensor Output: [1, 2, 3]

c = a[:, ::2]  # 选取所有行,步长为2
print(c)
# Tensor Output:
# [[0, 2, 4],
#  [5, 7, 9]] 

# 使用负索引
d = a[:, ::-1] # 反向选取每一行
print(d)
# Tensor Output:
# [[4, 3, 2, 1, 0], 
#  [9, 8, 7, 6, 5]]

# 使用0-D Tensor索引  
start = paddle.to_tensor(1)
end = paddle.to_tensor(4)
e = a[0, start:end]
print(e)
# Tensor Output: [1, 2, 3]

# 选取全部元素
f = a[:, :]
print(f)
# Tensor Output:
# [[0, 1, 2, 3, 4],
#  [5, 6, 7, 8, 9]]
```

可以看到,切片使用 `start:end:step` 的格式,可以很方便地选取指定轴上的一个区间内的元素。省略号:或::代表选取全部元素。负数索引从最后开始计数。0-D Tensor 也可以用于索引。

下面的示例展示了在多个维度上同时使用切片索引:

```python
g = a[:, 1:4:2]
print(g)
# Tensor Output: 
# [[1, 3],
#  [6, 8]]

h = a[0, :, ::2]  
print(h)
# Tensor Output: [0, 2, 4]
```

g 在第二个维度上选取了步长为 2 的区间 [1,4)。h 先在第一个维度选取第一行,再在第二个维度上步长为 2 选取全部元素。

slice 对象提供了一种简洁高效的方式选取指定轴上的一个区间内的元素,在数据预处理、模型微调等场景中非常实用。可以灵活组合使用不同的 start/end/step 参数满足多种需求。

### 3.3 使用Python Ellipsis对象作为索引

省略号对象 `...` 是多个连续的  `slice`对象 `:` 的简写, 可以出现在索引中任意位置, 但只能出现一次。它用于表示对所表示的单个或多个轴进行全选切片。在实际使用时, 会根据省略号前后的索引情况, 自动推断出所代表的轴。

以下是一些使用Ellipsis对象的示例:

```python
import paddle

# 创建3维张量作为示例
a = paddle.arange(24).reshape((2,3,4))
print(a)
# Tensor Output:
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]]

# ...等价于全选切片
b = a[...]
print(b)
# Tensor Output: 和a完全相同
# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
#  [[12 13 14 15]
#   [16 17 18 19] 
#   [20 21 22 23]]]

# 选取第二个2x3x4子张量的全部元素  
c = a[1,...]
print(c)
# Tensor Output:
# [[12 13 14 15]
#  [16 17 18 19]
#  [20 21 22 23]]

# 先选取第二个2x3子张量,再在次内部选取第一维度为0的元素
d = a[1,...,0]  
print(d)
# Tensor Output: [12 16 20]
```

可以看到, `...` 的作用是全选对应的维度。`a[...]` 就相当于 `a[:,:,:]`。`a[1,...]` 相当于 `a[1,:,:]` 先选取第二个 `2x3x4` 子张量。`a[1,...,0]` 相当于 `a[1,:,:,0]` 在子张量内部选取第一维度为 `0` 的所有元素。

Ellipsis 对象可以放在索引的任何位置,为不同场景提供了极大的方便,例如:

```python
# 选取第三列所有行的元素  
e = a[:,:,2]
print(e)
# Tensor Output:
# [[ 2  6 10]
#  [14 18 22]]

# 等价写法
f = a[...,:,2]  
print(f)
# Tensor Output:
# [[ 2  6 10]
#  [14 18 22]]
```

使用 Ellipsis 对象可以使索引写法变得简洁且可读性更强。它为高维 Tensor 的索引操作提供了极大的灵活性和便利性。当你需要选取一个子张量内部的全部或部分元素时, Ellipsis 是一个非常有用的工具。

### 3.4 使用 None 作为索引


在 Tensor 索引中, None(或np.newaxis,两者是等价的)通常用于在指定位置增加一个大小为 1 的新维度。它的作用类似于NumPy 中的 None 或 newaxis。

下面是一些使用None进行索引的示例:

```python
import paddle
import numpy as np

a = paddle.arange(6).reshape((2,3))
print(a)
# Tensor Output: 
# [[0, 1, 2],
#  [3, 4, 5]]

# 在最外层增加一个大小为1的维度
b = a[None, :]
print(b)
# Tensor Output:
# [[[0, 1, 2],
#   [3, 4, 5]]]

# 在内部增加一个大小为1的维度  
c = a[:, None, :]
print(c)  
# Tensor Output:
# [[[0, 1, 2]], 
#  [[3, 4, 5]]]

# 同时在多个位置增加大小为1的维度
d = a[None, :, None, :]
print(d)
# Tensor Output: 
# [[[[0, 1, 2]],
#   [[3, 4, 5]]]]

# None和np.newaxis是等价的
e = a[np.newaxis, :, np.newaxis, :]
print(e)
# Tensor Output: 和d完全相同
```

可以看到,None 在不同位置的作用是在该位置增加一个大小为 1 的新维度。这种操作在某些情况下非常有用, 例如:

```python
# 对一个向量广播到矩阵
f = paddle.arange(3)[:, None]
print(f)
# Tensor Output:
# [[0],
#  [1], 
#  [2]]

g = paddle.arange(2)[None, :]
print(g)  
# Tensor Output:
# [[0, 1]]

# 将两个向量外积到矩阵
h = f @ g.T
print(h)
# Tensor Output:
# [[0, 0],
#  [0, 1],
#  [0, 2]]
```

这里 f 和 g 分别通过None增加一个新维度,使其形状变为 (3,1) 和 (1,2),然后就可以直接做矩阵乘法了。

None 索引操作为处理不同形状的 Tensor 数据提供了很大的方便,能够灵活地对 Tensor 的维度进行调整, 使之满足后续计算的需求, 非常实用。

> 注意：在动态图模式下，通过基础索引取值时，输出将是原 Tensor 的 view，即如果对输出 Tensor 再进行修改，会影响原 Tensor 的值。而在静态图模式下，输出是一个新的 Tensor。由于在两种模式下存在差异，请谨慎使用这个特性。


## 4. 高级索引

高级索引是指使用整数数组、布尔数组或它们的组合来对 Tensor 进行索引。与基础索引不同,高级索引会返回一个全新的 Tensor, 而不是原 Tensor 的视图。

### 4.1 使用整数数组索引

整形数组索引允许使用非0维的Tensor/Ndarray或Python List对另一个Tensor进行索引。它支持任意选择Tensor中的元素并重新组合,非常灵活。

```python
a = paddle.arange(8).reshape((4,2))
b = a[[0,2,1]]  # 使用Python列表,选取第0、2、1行
c = a[np.array([0,1,0])]  # 使用Numpy数组,第0行被选取两次

index = paddle.to_tensor([[1], [2]]) 
d = a[index]  # 使用二维Tensor索引,先选取行,再按index的第二维度组合

e = a[[2,0,3],[1,0,0]] # 在两个维度上分别使用不同的整数索引
```

可以看出,整形数组索引可以使用Python列表、Numpy数组或Paddle Tensor作为索引。通过指定的索引值,可以任意选取Tensor中的行或列,并可以重复选择。索引还可以是高维的,在不同轴上分别使用不同的整数索引值。

当在多个轴上同时使用整形数组索引时,将根据指定的索引顺序和形状进行对应的组合选择,并遵循广播规则。如果不满足广播条件,将导致错误。

```python
f = a[[0,2,1], [0]]  # 在不同轴使用不同的整形数组索引
```

整形数组索引提供了极大的灵活性,支持任意元素的选取和组合,在 embedding 查找、数据采样等任务中非常有用。通过合理选择索引值,可以满足复杂的高维数据选取需求。

### 4.2 使用布尔数组索引

布尔索引是另一种高级索引方式,它使用布尔值(True或False)作为索引,选取出满足条件的元素。这类似于掩码(mask)的操作。

根据索引的类型不同,布尔索引可以分为两种情况:

1. 当索引为布尔型的Tensor/Ndarray/List时:
    - 索引的rank必须小于或等于被索引Tensor的rank
    - 引的每一维度大小必须与被索引Tensor对应维度相同

```python 
a = paddle.arange(8).reshape((4,2))
mask = a > 4  # 创建一个布尔Tensor作为掩码
b = a[mask]   # 选取大于4的元素
print(b)
# Tensor Output: [5, 6, 7]

c = a[[True, False, True, False]] # 使用布尔列表选取第0和2行 
print(c)
# Tensor Output: 
# [[0, 1],
#  [4, 5]]
```

在这种情况下,布尔索引可通过 nonzero() 方法与整形数组索引等价。


2. 当索引为单个Python布尔值时:
    - 等价于先在最外层添加一个新维度,再根据布尔值选取

```python
d = a[True]   # 在最外层添加新维度,选取整个Tensor
print(d)
# Tensor Output:
# [[[0, 1],
#   [2, 3],
#   [4, 5], 
#   [6, 7]]]

e = a[False]  # 无元素被选取,返回0维Shape Tensor  
print(e)
# Tensor Output: []
```

```python
d = a[True]   # 在最外层添加新维度,选取整个Tensor
print(d)
# Tensor Output:
# [[[0, 1],
#   [2, 3],
#   [4, 5], 
#   [6, 7]]]

e = a[False]  # 无元素被选取,返回0维Shape Tensor  
print(e)
# Tensor Output: []
```

需要注意的是,如果在布尔索引过程中没有任何元素被选中,输出将是一个0维Shape Tensor,不包含具体数据。

布尔索引为数据选取提供了方便的掩码功能,能精确选取满足条件的元素。通过合理构造掩码Tensor/列表,可以高效完成一些数据过滤、子集采样等任务。

### 4.3 联合索引

联合索引指的是在同一个索引操作中,混合使用基础索引(如整数索引、切片索引)和高级索引(如整形数组索引、布尔索引)。这种索引方式提供了更大的灵活性,可以满足复杂的数据选取需求。

在联合索引中,计算顺序是先执行基础索引,再执行高级索引。这一点非常重要,因为基础索引可能会降低被索引Tensor的维度,进而影响后续高级索引的操作。

例如:

```python
import paddle

a = paddle.arange(24).reshape((2,3,4))

# 先基础索引选取子张量,再高级索引进一步选取
b = a[0,[1,2],2]
print(b)
# 等价于:
# tmp = a[0,:,2] # 基础索引先选取第一个张量的第三维
# b = tmp[[1,2]] # 高级索引在tmp上进一步选取第2和3行
# Tensor Output: [6, 10]
```

在一些情况下,索引操作中可能包含多个高级索引,这时索引的计算顺序将遵循广播规则。另外,最终输出Tensor的形状,取决于高级索引在索引表达式中的相对位置。

例如:
```python
# 高级索引相邻,新维度出现在第一个高级索引的位置
c = a[:,[0,0,1],[1,2,0],:]
print(c) 
# Tensor Output: [[[4, 5, 6, 7],
#                  [8, 9,10,11], 
#                 [12,13,14,15]]]

# 高级索引不相邻,新维度将在最外层
d = a[:,[1],:,[2,1,0]]
print(d)
# Tensor Output: [[[14,18,22]],
#                 [[13,17,21]],
#                 [[12,16,20]]]
```

可见,联合索引极大拓展了张量索引的能力和表现力,能够高效完成对高维数据的复杂选取操作,是数据处理和模型开发中一种非常强大的工具。


... 还在写，没写完 （doge）
